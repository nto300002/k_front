はい、承知いたしました。
これまでの議論を全て統合し、アプリケーション「ケイカくん」のフロントエンド開発に着手するための、包括的で詳細な設計書を作成します。

---

### **フロントエンド詳細設計書: ケイカくん**

**1. 基本的な設計思想と技術選定**

*   **アーキテクチャ**: Next.js App Routerを基本とし、**サーバーコンポーネント**による高速な初期表示と、**クライアントコンポーネント**による豊かなインタラクティビティを両立させる「アイランドアーキテクチャ」を採用します。
*   **コンポーネント指向**: UIを再利用可能な小さなコンポーネントに分割し、それらを組み合わせてページを構築します。共通コンポーネントとページ専用コンポーネントを明確に分離します。
*   **関心の分離**: 「データ取得ロジック (`lib/`)」「UIコンポーネント (`components/`)」「状態管理ロジック (`hooks/`, `contexts/`)」「ページの構成 (`app/`)」の責務を明確に分離します。
*   **型安全**: TypeScriptを最大限に活用し、APIレスポンスからUIのPropsまで、`types/`ディレクトリで管理される厳格な型定義を行います。

**2. ディレクトリ構成とファイル配置**

```
keikakun_front/
├── app/
│   ├── (auth)/                # 認証関連ページグループ (ログイン、サインアップ)
│   ├── (main)/                # メイン機能ページグループ (ヘッダー・フッター共有)
│   │   ├── dashboard/           # ダッシュボード
│   │   ├── recipients/          # 利用者関連 (新規、編集、個別計画など)
│   │   ├── profile/             # プロフィール
│   │   ├── admin/               # 管理者専用ページ
│   │   └── layout.tsx           # メイン機能の共通レイアウト (ヘッダー/フッター)
│   └── layout.tsx               # ルートレイアウト (<html>, <body>)
│
├── components/                  # ★ 全アプリケーションで共通のUIコンポーネント
│   ├── ui/                      # shadcn/uiで生成される基本部品 (Button, Input等)
│   ├── common/                  # 複数のページで使われる共通部品 (Header, Footer, Modal)
│   └── icons/                   # カスタムアイコンコンポーネント
│
├── contexts/                    # ★ グローバルな状態を管理するContext
│   └── AuthContext.tsx          # 認証状態とユーザー情報を管理
│
├── hooks/                       # ★ 再利用可能なカスタムフック
│   ├── useAuth.ts               # AuthContextを簡単に利用するためのフック
│   └── useSWRMutation.ts      # (任意) POST/PATCH/DELETE用のSWRフック
│
├── lib/                         # ★ データ取得・外部サービス連携ロジック
│   ├── api/                     # バックエンドAPIを呼び出す関数群 (エンドポイント毎に分割)
│   │   ├── authApi.ts
│   │   ├── dashboardApi.ts
│   │   └── recipientApi.ts
│   └── supabase/                # Supabaseクライアントの初期化・設定
│
├── types/                       # ★ アプリケーション全体の型定義
│   ├── api/                     # APIレスポンスの型 (バックエンドのschemaに対応)
│   │   ├── auth.d.ts
│   │   └── dashboard.d.ts
│   └── index.d.ts               # グローバルな型やEnum
│
└── middleware.ts                # ★ ページ保護のための認証ミドルウェア
```

**3. 命名規則**

*   **ファイル名**: コンポーネント、フック、APIファイルは**パスカルケース (PascalCase)** (`DashboardTable.tsx`)。型定義ファイルは**ケバブケース (kebab-case)** (`dashboard.d.ts`)。
*   **関数・変数名**: **キャメルケース (camelCase)** (`getUserProfile`)。
*   **API取得関数**: `get`, `create`, `update`, `delete` などの動詞で始める (`getDashboardData`)。

**4. 状態管理とデータフロー戦略**

| 状態の種類 | 管理方法 | 具体例 |
| :--- | :--- | :--- |
| **サーバーの状態** (DBデータ) | **SWR** または **TanStack Query** | 利用者一覧、計画履歴データ。キャッシュ、再検証、ローディング/エラー状態を管理。 |
| **グローバルなクライアント状態** | **Context API** + **カスタムフック** | 認証状態 (`user`, `isLoggedIn`)。アプリ全体で共有。 |
| **ローカルなUI状態** | **`useState` / `useReducer`** | フォームの入力値、モーダルの開閉状態、トグルのON/OFF。コンポーネント内で完結。 |

*   **基本データフロー**:
    1.  **サーバーコンポーネント (`page.tsx`)**: `async/await`で`lib/api/`の関数を呼び出し、初期データを取得。
    2.  **クライアントコンポーネント**: サーバーから渡された初期データを`SWR`等の`fallbackData` / `initialData`として使用し、クライアントサイドでのインタラクションや再検証に対応する。

**5. ページ別 詳細設計**

#### **a. 認証ページ (`/login`, `/signup`, `/admin/signup`)**

*   **コンポーネント種別**: 全て**クライアントコンポーネント**。
*   **ロジック**:
    *   `react-hook-form`と`zod`でフォームとバリデーションを実装。
    *   `useAuth()`フックから`login`, `signupAdmin`などの関数を呼び出す。
    *   `onSubmit`でAPI通信を行い、成功後は`next/router`でページ遷移、失敗時はフォームにエラーメッセージを表示。

#### **b. ダッシュボード (`/dashboard`)**

*   **`page.tsx` (サーバーコンポーネント)**:
    *   `dashboardApi.getDashboardData()`を呼び出し、利用者サマリー、事業所名、課金情報などを一括取得。
    *   取得したデータを`DashboardClient`（仮名）コンポーネントにPropsとして渡す。
*   **`DashboardClient.tsx` (クライアントコンポーネント)**:
    *   SWRを使い、サーバーから受け取ったデータを初期値としてクライアントの状態を管理。
    *   **課金ロジック**: 新規登録ボタンクリック時に、Propsで受け取った`currentUserCount`と`billingStatus`を基に、課金モーダルを表示するか、`/recipients/new`に遷移するかを決定する。
    *   **表示ロジック**: `date-fns`を使い、期限日までの残り日数を計算して表示。

#### **c. 個別支援計画ページ (`/recipients/[id]/plan`)**

*   **`page.tsx` (サーバーコンポーネント)**:
    *   `planApi.getPlanData(params.id)`を呼び出し、特定利用者の全ての計画サイクル、ステータス、成果物情報を取得。
*   **クライアントコンポーネント群**:
    *   `PlanStepCell`: 各ステップの状態に応じて、完了マークやアップロードボタンを表示。クリックでモーダルを開く。
    *   `PdfUploadModal`: ファイルアップロードのUIとロジック。`useSWRMutation`などを使い、`POST /plan-deliverables`を実行。成功後、SWRのキャッシュを`mutate`して一覧を自動更新。
    *   `FilePreview`: 削除ボタンを持ち、`DELETE`リクエストを送信する。

**6. 認証とページ保護 (`middleware.ts`)**

*   **役割**: サーバーサイドでリクエストをインターセプトし、認証が必要なページへのアクセスを制御する。
*   **ロジック**:
    1.  リクエストのパスが保護対象（例: `/dashboard/*`, `/recipients/*`）か判定。
    2.  保護対象の場合、クッキーからSupabaseのセッショントークンを取得。
    3.  Supabase Clientを使い、トークンの有効性をサーバーサイドで検証。
    4.  トークンが無効な場合、ログインページ (`/login`) へリダイレクトさせる。
    5.  有効な場合は、リクエストをそのまま通過させる。

**7. レスポンシブデザイン**

*   **基本**: Tailwind CSSのモバイルファーストアプローチとブレークポイント（`sm:`, `md:`, `lg:`）を全面的に採用する。
*   **特殊レイアウト**: `react-masonry-css`は、写真ギャラリーのような高さが不揃いな要素のグリッド表示など、特定のUI要件が発生した場合に限定的に導入を検討する。